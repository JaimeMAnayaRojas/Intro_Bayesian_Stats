siberDensityPlot(layman.B[[1]], xticklabels = colnames(layman.B[[1]]),
bty="L", ylim = c(0,20))
# add the ML estimates (if you want). Extract the correct means
# from the appropriate array held within the overall array of means.
comm1.layman.ml <- laymanMetrics(siber.example$ML.mu[[1]][1,1,],
siber.example$ML.mu[[1]][1,2,]
)
points(1:6, comm1.layman.ml$metrics, col = "red", pch = "x", lwd = 2)
# --------------------------------------
# Visualise the second community
# --------------------------------------
siberDensityPlot(layman.B[[2]], xticklabels = colnames(layman.B[[2]]),
bty="L", ylim = c(0,20))
# add the ML estimates. (if you want) Extract the correct means
# from the appropriate array held within the overall array of means.
comm2.layman.ml <- laymanMetrics(siber.example$ML.mu[[2]][1,1,],
siber.example$ML.mu[[2]][1,2,]
)
points(1:6, comm2.layman.ml$metrics, col = "red", pch = "x", lwd = 2)
# go back to a 1x1 panel plot
par(mfrow=c(1,1))
siberDensityPlot(cbind(layman.B[[1]][,"TA"], layman.B[[2]][,"TA"]),
xticklabels = c("Community 1", "Community 2"),
bty="L", ylim = c(0,20),
las = 1,
ylab = "TA - Convex Hull Area",
xlab = "")
# remove previously loaded items from the current environment and remove previous graphics.
rm(list=ls())
graphics.off()
# Here, I set the seed each time so that the results are comparable.
# This is useful as it means that anyone that runs your code, *should*
# get the same results as you, although random number generators change
# from time to time.
set.seed(1)
library(SIBER)
fname <- system.file("extdata", "demo.siber.data.csv", package = "SIBER")
mydata <- read.csv(fname, header=T)
siber.example <- createSiberObject(mydata)
head(mydata)
siber.example <- createSiberObject(mydata)
# Create lists of plotting arguments to be passed onwards to each
# of the three plotting functions.
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")
par(mfrow=c(1,1))
plotSiberObject(siber.example,
ax.pad = 2,
hulls = F, community.hulls.args,
ellipses = T, group.ellipses.args,
group.hulls = T, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab = expression({delta}^13*C~'\u2030'),
ylab = expression({delta}^15*N~'\u2030')
)
par(mfrow=c(1,1))
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = F, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# Calculate summary statistics for each group: TA, SEA and SEAc
group.ML <- groupMetricsML(siber.example)
print(group.ML)
# You can add more ellipses by directly calling plot.group.ellipses()
# Add an additional p.interval % prediction ellilpse
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
lty = 1, lwd = 2)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95, ci.mean = T,
lty = 1, lwd = 2)
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = T, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
ci.mean = T, lty = 1, lwd = 2)
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = T, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95, ci.mean = T,
lty = 1, lwd = 2)
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = F, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# Calculate summary statistics for each group: TA, SEA and SEAc
group.ML <- groupMetricsML(siber.example)
print(group.ML)
# You can add more ellipses by directly calling plot.group.ellipses()
# Add an additional p.interval % prediction ellilpse
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
lty = 1, lwd = 2)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95, ci.mean = T,
lty = 1, lwd = 2)
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = T, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
ci.mean = T, lty = 1, lwd = 2)
# Calculate the various Layman metrics on each of the communities.
community.ML <- communityMetricsML(siber.example)
print(community.ML)
# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains
# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3
# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the
# means. Fitting is via the JAGS method.
ellipses.posterior <- siberMVN(siber.example, parms, priors)
# The posterior estimates of the ellipses for each group can be used to
# calculate the SEA.B for each group.
SEA.B <- siberEllipses(ellipses.posterior)
siberDensityPlot(SEA.B, xticklabels = colnames(group.ML),
xlab = c("Community | Group"),
ylab = expression("Standard Ellipse Area " ('\u2030' ^2) ),
bty = "L",
las = 1,
main = "SIBER ellipses on each group"
)
# Add red x's for the ML estimated SEA-c
points(1:ncol(SEA.B), group.ML[3,], col="red", pch = "x", lwd = 2)
# Calculate some credible intervals
cr.p <- c(0.95, 0.99) # vector of quantiles
# call to hdrcde:hdr using lapply()
SEA.B.credibles <- lapply(
as.data.frame(SEA.B),
function(x,...){tmp<-hdrcde::hdr(x)$hdr},
prob = cr.p)
as.data.frame(SEA.B)
# remove previously loaded items from the current environment and remove previous graphics.
rm(list=ls())
graphics.off()
# Here, I set the seed each time so that the results are comparable.
# This is useful as it means that anyone that runs your code, *should*
# get the same results as you, although random number generators change
# from time to time.
set.seed(1)
library(SIBER)
fname <- system.file("extdata", "demo.siber.data.csv", package = "SIBER")
mydata <- read.csv(fname, header=T)
head(mydata)
siber.example <- createSiberObject(mydata)
# Create lists of plotting arguments to be passed onwards to each
# of the three plotting functions.
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")
par(mfrow=c(1,1))
plotSiberObject(siber.example,
ax.pad = 2,
hulls = F, community.hulls.args,
ellipses = T, group.ellipses.args,
group.hulls = T, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab = expression({delta}^13*C~'\u2030'),
ylab = expression({delta}^15*N~'\u2030')
)
par(mfrow=c(1,1))
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = F, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# Calculate summary statistics for each group: TA, SEA and SEAc
group.ML <- groupMetricsML(siber.example)
print(group.ML)
# You can add more ellipses by directly calling plot.group.ellipses()
# Add an additional p.interval % prediction ellilpse
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
lty = 1, lwd = 2)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95, ci.mean = T,
lty = 1, lwd = 2)
# this time we will make the points a bit smaller by
# cex = 0.5
plotSiberObject(siber.example,
ax.pad = 2,
hulls = T, community.hulls.args,
ellipses = F, group.ellipses.args,
group.hulls = F, group.hull.args,
bty = "L",
iso.order = c(1,2),
xlab=expression({delta}^13*C~'\u2030'),
ylab=expression({delta}^15*N~'\u2030'),
cex = 0.5
)
# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(siber.example, n = 100, p.interval = 0.95,
ci.mean = T, lty = 1, lwd = 2)
# Calculate the various Layman metrics on each of the communities.
community.ML <- communityMetricsML(siber.example)
print(community.ML)
# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains
# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3
# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the
# means. Fitting is via the JAGS method.
ellipses.posterior <- siberMVN(siber.example, parms, priors)
# The posterior estimates of the ellipses for each group can be used to
# calculate the SEA.B for each group.
SEA.B <- siberEllipses(ellipses.posterior)
SEA.B
siberDensityPlot(SEA.B, xticklabels = colnames(group.ML),
xlab = c("Community | Group"),
ylab = expression("Standard Ellipse Area " ('\u2030' ^2) ),
bty = "L",
las = 1,
main = "SIBER ellipses on each group"
)
apply(SEA.B, 2, mean)
library(rethinking)
apply(SEA.B, 2, HPDI, prob=.95)
apply(SEA.B, 2, sd)
siberDensityPlot(SEA.B, xticklabels = colnames(group.ML),
xlab = c("Community | Group"),
ylab = expression("Standard Ellipse Area " ('\u2030' ^2) ),
bty = "L",
las = 1,
main = "SIBER ellipses on each group"
)
# Add red x's for the ML estimated SEA-c
points(1:ncol(SEA.B), group.ML[3,], col="red", pch = "x", lwd = 2)
# Calculate some credible intervals
cr.p <- c(0.95, 0.99) # vector of quantiles
# call to hdrcde:hdr using lapply()
SEA.B.credibles <- lapply(
as.data.frame(SEA.B),
function(x,...){tmp<-hdrcde::hdr(x)$hdr},
prob = cr.p)
# do similar to get the modes, taking care to pick up multimodal posterior
# distributions if present
SEA.B.modes <- lapply(
as.data.frame(SEA.B),
function(x,...){tmp<-hdrcde::hdr(x)$mode},
prob = cr.p, all.modes=T)
# extract the posterior means
mu.post <- extractPosteriorMeans(siber.example, ellipses.posterior)
# calculate the corresponding distribution of layman metrics
layman.B <- bayesianLayman(mu.post)
layman.B
# remove previously loaded items from the current environment and remove previous graphics.
rm(list=ls())
# variables
height <- 4
height
height = 5
height
width <- 3
#calculate the are of a rectangle
area = height * width
area
# variables can also strore many entries
numbers = 1:100
numbers
# letters are store as characters,
letters = c("a", "b", "c")
letters
# you can also use your variable as factors, where values are id by levels
animals = c('mammals', 'birds', "reptiles", 'amphibians', 'humans')
animals = factor(animals)
levels(animals)
levels(animals)[3] <- "mammals"
levels(animals)
animals
# Do this part in R directly
# install.packages(c("coda","mvtnorm","devtools","loo","dagitty", 'rstan', "brms", "readxl"))
# library(devtools)
# devtools::install_github("rmcelreath/rethinking")
# load the packages
library(rethinking)
library(brms)
library('readxl')
setwd("/home/mauriciok8/Dropbox/Projects_JM/Muenster/Intro_Bayesian_Stats/")
data = read_xls("Examples//Anaya-Rojas et al 2016/Fish_and_TankData.xls")
data[1:8,]
data$Origin = factor(data$Origin)
levels(data$Origin)
data$Nutrients = factor(data$Nutrients)
levels(data$Nutrients)
data$Exposure = factor(data$Exposure)
levels(data$Exposure)
data$Lake = ifelse(data$Origin == "Lake", 1, 0)
data$High = ifelse(data$Nutrients == "high", 1, 0)
data$G = ifelse(data$Exposure == 'G+', 1, 0)
data$CI = log(data$HIS)
data$Gyro = log(data$Gyrocount+1)
data$Tank = factor(data$Tank)
levels(data$Tank) = 1:length(levels(data$Tank))
data$Block = factor(data$Block)
levels(data$Block) = 1:length(levels(data$Block))
# variables
height <- 4
height
height = 5
height
width <- 3
#calculate the are of a rectangle
area = height * width
area
# variables can also strore many entries
numbers = 1:100
numbers
# letters are store as characters,
letters = c("a", "b", "c")
letters
# you can also use your variable as factors, where values are id by levels
animals = c('mammals', 'birds', "reptiles", 'amphibians', 'humans')
animals = factor(animals)
levels(animals)
levels(animals)[3] <- "mammals"
levels(animals)
animals
# Do this part in R directly
# install.packages(c("coda","mvtnorm","devtools","loo","dagitty", 'rstan', "brms", "readxl"))
# library(devtools)
# devtools::install_github("rmcelreath/rethinking")
# load the packages
library(rethinking)
library(brms)
library('readxl')
setwd("/home/mauriciok8/Dropbox/Projects_JM/Muenster/Intro_Bayesian_Stats/")
data = read_xls("Examples//Anaya-Rojas et al 2016/Fish_and_TankData.xls")
data[1:8,]
data$Origin = factor(data$Origin)
levels(data$Origin)
data$Nutrients = factor(data$Nutrients)
levels(data$Nutrients)
data$Exposure = factor(data$Exposure)
levels(data$Exposure)
data$Lake = ifelse(data$Origin == "Lake", 1, 0)
data$High = ifelse(data$Nutrients == "high", 1, 0)
data$G = ifelse(data$Exposure == 'G+', 1, 0)
data$CI = log(data$HIS)
data$Gyro = log(data$Gyrocount+1)
data$Tank = factor(data$Tank)
levels(data$Tank) = 1:length(levels(data$Tank))
data$Block = factor(data$Block)
levels(data$Block) = 1:length(levels(data$Block))
m.data = data[,c("CI", 'Lake','High','G','Tank','Block','Gyro')]
# Do this part in R directly
# install.packages(c("coda","mvtnorm","devtools","loo","dagitty", 'rstan', "brms", "readxl"))
# library(devtools)
# devtools::install_github("rmcelreath/rethinking")
rm(list=ls(all=TRUE))
# load the packages
library(rethinking)
library(brms)
library('readxl')
setwd("/home/mauriciok8/Dropbox/Projects_JM/Muenster/Intro_Bayesian_Stats/")
data = read_xls("Examples//Anaya-Rojas et al 2016/Fish_and_TankData.xls")
data[1:8,]
data$Origin = factor(data$Origin)
levels(data$Origin)
data$Nutrients = factor(data$Nutrients)
levels(data$Nutrients)
data$Exposure = factor(data$Exposure)
levels(data$Exposure)
data$Lake = ifelse(data$Origin == "Lake", 1, 0)
data$High = ifelse(data$Nutrients == "high", 1, 0)
data$G = ifelse(data$Exposure == 'G+', 1, 0)
data$CI = log(data$HIS)
data$Gyro = log(data$Gyrocount+1)
data$Tank = factor(data$Tank)
levels(data$Tank) = 1:length(levels(data$Tank))
levels(data$Tank)
# variables
height <- 4
height
height = 5
height
width <- 3
#calculate the are of a rectangle
area = height * width
area
# variables can also strore many entries
numbers = 1:100
numbers
# letters are store as characters,
letters = c("a", "b", "c")
letters
# you can also use your variable as factors, where values are id by levels
animals = c('mammals', 'birds', "reptiles", 'amphibians', 'humans')
animals = factor(animals)
levels(animals)
levels(animals)[3] <- "mammals"
levels(animals)
animals
# Do this part in R directly
# install.packages(c("coda","mvtnorm","devtools","loo","dagitty", 'rstan', "brms", "readxl"))
# library(devtools)
# devtools::install_github("rmcelreath/rethinking")
rm(list=ls(all=TRUE))
# load the packages
library(rethinking)
library(brms)
library('readxl')
setwd("/home/mauriciok8/Dropbox/Projects_JM/Muenster/Intro_Bayesian_Stats/")
data = read_xls("Examples//Anaya-Rojas et al 2016/Fish_and_TankData.xls")
data[1:8,]
data$Origin = factor(data$Origin)
levels(data$Origin)
data$Nutrients = factor(data$Nutrients)
levels(data$Nutrients)
data$Exposure = factor(data$Exposure)
levels(data$Exposure)
data$Lake = ifelse(data$Origin == "Lake", 1, 0)
data$High = ifelse(data$Nutrients == "high", 1, 0)
data$G = ifelse(data$Exposure == 'G+', 1, 0)
data$CI = log(data$HIS)
data$Gyro = log(data$Gyrocount+1)
m.data = data[,c("CI", 'Lake','High','G','Tank','Block','Gyro')]
m.data$Tank = factor(m.data$Tank)
levels(m.data$Tank) = 1:length(levels(m.data$Tank))
levels(m.data$Tank)
m.data$Block = factor(m.data$Block)
levels(m.data$Block) = 1:length(levels(m.data$Block))
levels(m.data$Block)
